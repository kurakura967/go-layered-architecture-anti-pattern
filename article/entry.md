# レイヤードアーキテクチャから学ぶ密結合と疎結合
## 目次
  - 本記事でやること
  - 対象読者
  - 使用言語
  - 背景
  - レイヤードアーキテクチャの紹介
  - レイヤードアーキテクチャにおける密結合なコードの紹介
  - 密結合だと何が問題なのか
  - 疎結合なコードに変更する
  - 疎結合にすると何が良いのか
  - 依存の向き
  - まとめ

## 背景
- 密結合なコードよりも疎結合なコードが良いとされている。
- 密結合なコードだとどういう問題があるのか、意外と腑に落ちていないことがあった
  - 密結合と疎結合をモノに例えたりして説明することが多いがそれだけだと腑に落ちない
  - より実務な内容で密結合と疎結合について考えることができないかと考えた
- より実践に沿った内容であることを目指し、レイヤードアーキテクチャを題材として密結合と疎結合について考える

## レイヤードアーキテクチャの紹介
レイヤードアーキテクチャは、アプリケーションが持つ責務をいくつかの層に分け、各層の依存の向きを一方向に制御する、設計パターンの1つです。
この他にも、クリーンアーキテクチャやオニオンアーキテクチャなどがありますが、各設計パターンの目的はアプリケーションの責務を定義し、依存の向きを明確にすることで共通していると思っています。

今回は、レイヤードアーキテクチャを題材に密結合と疎結合について考えていきます。
簡略化のため、以下の3層のみを考えます。また、想定するアプリケーションは入力されたユーザーIDを元にデータベースからユーザー名を取得するというものとします。
そのため、各層内で定義しているメソッドも合わせて記載してあります。


| レイヤー | 責務                     | メソッド           |
| --- |------------------------|----------------|
| Presentation | ユーザーからの入力を受け取り、Usecase層に渡す | GetUserHandler |
| Usecase | ユーザーからの入力を元にユーザー名を取得する | GetUserById    |
| Infra | データベースからユーザー名を取得する     | Get            |


## レイヤードアーキテクチャにおける密結合なコードの紹介

ソフトウェアにおける密結合な状態とは、あるモジュールが他のモジュールに強く依存しており、どちらかを変更するともう一方も変更する必要がある状態のことを指します。
レイヤードアーキテクチャに照らせ合わせて考えると、Usecase層(GetUserByIdメソッド)がInfra層(Getメソッド)に依存している状態です。
「どちらかを変更するともう一方も変更する必要がある状態」を以下のコードを用いて説明します。

```golang

```

ここで、infra層がアクセスするデータベースが変わった場合のことを考えます。
Usecase層のGetUserByIdメソッドの引数の型(sql.DB)やメソッド内で呼んでいるGetメソッドの引数の型(sql.DB)を変更する必要が出てきます。 
冒頭で説明した「どちらかを変更するともう一方も変更する必要がある状態」になっていることがわかります。
つまり、GetUserByIdメソッドとGetメソッドが密結合な状態になっていると言えます。


今、usecase層がinfra層に依存しております。(domain層とinfra層にしても良いかも)
- sql.DBの構造体をusecase層のコンストラクタに渡し、infra層のコンストラクタ(NewUserRepository)で受け取っている
- ここでdatabase/sqlからgormに変更した場合、usecase層のGetUserByIdメソッドの引数も変更する必要が出てくる
- このようにinfra層の変更にusecase層も変更する必要が出てくる状態を密結合と呼ぶ
  - usecase層が常にinfra層の実装の中身を知っておかないといけない状態になっている
  - 密結合な状態により、修正に弱いコードになってしまっている


## 密結合だと何が問題なのか
GetUserByIdとGetメソッドが密結合による問題点を以下にまとめます。

1. 変更に弱いコードになってしまう 
前章でも触れましたが、接続するデータベースが変わった場合にUsecase層も変更する必要が出てきてしまいます。

2. テストがしにくいコードになってしまう
Getメソッドの具象に依存していることで、usecase層の単体テスト時にGetメソッドをmockすることができず都度データベースに接続する必要が出てくる
都度データベースに接続するとテストが遅くなってしまいます。 
また、データベースに接続するということは、テストの度にデータベースの状態を初期化または必要なデータを用意する必要が出てきます。

3. 実装の順序が決まってしまう
Getメソッドの具象に依存することでをGetメソッドを実装するまでusecase層のメソッドを実装することができない


さらに、レイヤードアーキテクチャにおいては、Usecase層はビジネスロジックを定義している層であり、アプリケーション全体において最も大事な責務となっています。
つまり、Usecase層は他の層における変更の影響を受けにいく、安定度の高い層であるべきです。
ただし、現状のままだと、Usecase層とInfra層が密結合な状態になっているため、Usecase層の安定度が下がってしまっています。

Usecase層とInfra層が密結合な状態になっていることで、Usecase層の安定度が下がってしまっています。
これらの問題を解決するためにモジュール同士を疎結合なコードに変更していきます。

## 疎結合なコードに変更する
疎結合とは、モジュール間の結合度が低いことを指します。今回の場合、Usecase層とInfra層の依存関係を極力小さくし、各層の関心事に集中できるようにします。

疎結合なコードに変更するために以下2点を実施します。

1. 抽象に依存する
Go言語における"抽象"はインターフェイスを指すため、今回はインターフェイスが持つメソッドのシグネチャに依存するようにします。


2. Dependency Injectionを行う
モジュール間の結合を低くするために、外部から依存するコンポーネント(今回はインターフェース)を注入します。

```golang

```

## 疎結合にすると何が良いのか

GetUserByIdがGetメソッドの抽象に依存することで、以下のようなメリットがあります。

抽象に依存することで、Getメソッドの処理の詳細を知る必要がなくなり、Usecase層はユーザーIDを入力としてユーザー情報を返すことのみに関心が向けられます。
つまり、Getメソッドの具象を変更したとしても、Usecase層への影響はありません。 さらに、Getメソッドの具象を実装するまでUsecase層の実装を待つ必要もなくなります。

また、GetUserByIdメソッドの単体テスト時にGetメソッドをmockすることができるようになり、Getメソッドの中でデータベースにアクセスする必要がなくなり、テストがしやすくなります。

さらに、Dependency Injectionを行うことで、UserRepositorierインターフェイスの実装を満たせば、どのような型でも受けつけられるようになります。
例えば、利用するデータベースがSQLからElasticsearchへ変更した場合でも、UserRepositorierインターフェイスが持つGetメソッドのシグネチャを満たすように実装すれば、Usecase層のGetUserByIdメソッドの変更は必要ありません。

ここで、各層の依存の向きを確認してみましょう。
疎結合なコードに修正したことで、依存の向きが変わっていることがわかります。
GetUserByIdは同じくUsecase層で定義されているUserRepositorierインターフェイスのGetメソッドを呼び出し、infra層ではUserRepositorierインターフェイスを満たすように実装されています。
つまり、2つのモジュールが抽象(UserRepositorierインターフェイス)に依存するようになり、依存の向きがinfra層→usecase層となりました。

// TODO: クリーンアーキテクチャへ繋げる流れを再考する
Presentation層・infra層からUsecase層に向けて依存の向きが変わったことで、Usecase層が安定度の高い層となり、Presentation層・infra層の変更の影響を受けにいくようになりました。
このUsecase層を中心にPresentation層・infra層など外から中に依存が向いているアーキテクチャをクリーンアーキテクチャと呼びます。
つまり、クリーンアーキテクチャはアプリケーションにおける一番重要な層を中心におき、外から中に向けて依存の方向を保つことでビジネスロジックの安定度を高めるアーキテクチャです。


## まとめ
