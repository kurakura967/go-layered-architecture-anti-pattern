# レイヤードアーキテクチャから学ぶ密結合と疎結合
## 目次
  - 本記事でやること
  - 対象読者
  - 使用言語
  - 背景
  - レイヤードアーキテクチャの紹介
  - レイヤードアーキテクチャにおける密結合なコードの紹介
  - 密結合だと何が問題なのか
  - 疎結合なコードに変更する
  - 疎結合にすると何が良いのか
  - 依存の向き
  - まとめ

## 背景
- 密結合なコードよりも疎結合なコードが良いとされている。
- 密結合なコードだとどういう問題があるのか、意外と腑に落ちていないことがあった
  - 密結合と疎結合をモノに例えたりして説明することが多いがそれだけだと腑に落ちない
  - より実務な内容で密結合と疎結合について考えることができないかと考えた
- より実践に沿った内容であることを目指し、レイヤードアーキテクチャを題材として密結合と疎結合について考える

## レイヤードアーキテクチャの紹介

今回は簡略化のため以下のようなレイヤーのみを考える。
また、実装するアプリケーションは入力されたユーザーIDを元にデータベースからユーザー名を取得するというものとする。

## レイヤードアーキテクチャにおける密結合なコードの紹介

ソフトウェアにおける密結合な状態とは、あるモジュールが他のモジュールに強く依存しており、どたらかを変更するともう一方も変更する必要がある状態のことを指す。

今、usecase層がinfra層に依存しております。(domain層とinfra層にしても良いかも)
- sql.DBの構造体をusecase層のコンストラクタに渡し、infra層のコンストラクタ(NewUserRepository)で受け取っている
- ここでdatabase/sqlからgormに変更した場合、usecase層のGetUserByIdメソッドの引数も変更する必要が出てくる
- このようにinfra層の変更にusecase層も変更する必要が出てくる状態を密結合と呼ぶ
  - usecase層が常にinfra層の実装の中身を知っておかないといけない状態になっている
  - 密結合な状態により、修正に弱いコードになってしまっている


## 密結合だと何が問題なのか
- 接続するデータベースが変わった場合にusecase層も変更する必要が出てくる
- usecase層の単体テスト時にinfra層のメソッドをmockすることができず都度データベースに接続する必要が出てくる
- 具象に依存していることでGetメソッドを実装するまでusecase層のメソッドを実装することができない

### データベースを変更してみる
